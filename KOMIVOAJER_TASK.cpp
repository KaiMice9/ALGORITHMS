#include <iostream>
#include <vector>
#include <algorithm>
#include <climits>  // Для использования INT_MAX

using namespace std;

const int INF = INT_MAX / 2;  // "Бесконечность" (избегаем переполнения)

// Функция для решения задачи коммивояжёра (TSP) методом динамического программирования
int tsp(const vector<vector<int>>& dist, int n) {
    // full_mask - битовая маска, где все n битов установлены в 1 (все города посещены)
    const int full_mask = (1 << n) - 1;

    // Инициализация DP-таблицы:
    // dp[mask][v] = минимальная длина пути, проходящего через города из mask и заканчивающегося в v
    // Изначально все значения INF (пути неизвестны)
    vector<vector<int>> dp(1 << n, vector<int>(n, INF));

    // Базовый случай: начинаем из города 0 (бит 0 установлен в 1)
    // Расстояние от города 0 до самого себя = 0
    dp[1 << 0][0] = 0;

    // Перебираем все возможные маски (состояния посещённых городов)
    for (int mask = 0; mask <= full_mask; ++mask) {
        // Для каждого города v в текущей маске
        for (int v = 0; v < n; ++v) {
            // Пропускаем невозможные состояния (если путь до v в mask не найден)
            if (dp[mask][v] == INF) continue;

            // Перебираем все города u, которые ещё не посещены (!(mask & (1 << u)))
            for (int u = 0; u < n; ++u) {
                if (!(mask & (1 << u))) {  // Если город u не посещён
                    // Новая маска: старая маска + добавленный город u
                    int new_mask = mask | (1 << u);
                    // Обновляем DP: сравниваем текущее значение с новым путём (v → u)
                    dp[new_mask][u] = min(dp[new_mask][u], dp[mask][v] + dist[v][u]);
                }
            }
        }
    }

    // Поиск минимального цикла (возврат в стартовый город 0)
    int min_cycle = INF;
    for (int v = 1; v < n; ++v) {
        // Проверяем, что есть путь через все города, заканчивающийся в v,
        // и существует обратный путь из v в 0
        if (dp[full_mask][v] != INF && dist[v][0] != INF) {
            // Общая длина цикла: путь full_mask → v + расстояние v → 0
            min_cycle = min(min_cycle, dp[full_mask][v] + dist[v][0]);
        }
    }

    // Если цикл не найден, вернём -1, иначе — длину минимального цикла
    return (min_cycle == INF) ? -1 : min_cycle;
}

int main() {
    // Пример матрицы расстояний между 4 городами (0, 1, 2, 3)
    // dist[i][j] = расстояние от города i до города j
    vector<vector<int>> dist = {
        {0, 10, 15, 20},   // Расстояния из города 0
        {10, 0, 35, 25},    // Расстояния из города 1
        {15, 35, 0, 30},    // Расстояния из города 2
        {20, 25, 30, 0}     // Расстояния из города 3
    };

    // Вызов функции и вывод результата
    int result = tsp(dist, 4);
    cout << "Min TSP cycle length: " << result << endl;  // Ожидаемый ответ: 80 (0 → 1 → 3 → 2 → 0)
    return 0;
}